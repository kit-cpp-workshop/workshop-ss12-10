\section{Datenstrukturen}

\begin{frame}{Hashtable}
 	\begin{block}{Hashing}
	 	\begin{itemize}
	 		\item (Schnelles) Finden durch Unordnung
	 		\item \enquote{to hash} = zerhacken
			\pause
	 		\item Trick: Hashfunktionen bilden (komplexe) Objekte (durcheinander) auf einfache Zahlen (Hashwerte) ab
	 		\item Hashwerte dienen als Indizes in der Hashtabelle
	 		\item Folge: (Fast) direkte Abbildung Schl√ºsselobjekt $\rightarrow$ Element
	 	\end{itemize}
 	\end{block}
 	
 	\pause
 	
 	\begin{center}
		\includegraphics[width=0.95\linewidth]{images/hashmap.pdf}
	\end{center}
\end{frame}

\begin{frame}{Hashtables in C++}
 	\begin{block}{\texttt{std::unordered\_map} (ab C++11)}
	 	\begin{itemize}
	 		\item \texttt{find(key)}
	 		\item \texttt{operator[key]}
	 		\item \texttt{insert(pair<key, value>)}
	 		\item \texttt{erase(key)}
	 	\end{itemize}
	 	\pause
	 	Alles (amortisiert) in $\mathcal{O}(1)$
 	\end{block}
 	
 	\begin{itemize}
 		\item \texttt{unordered\_map} vs. \texttt{map}
 		\begin{itemize}
 			\item Wichtige Operationen in $\mathcal{O}(1)$ statt $\mathcal{O}(log(n))$
 			\item \texttt{unordered\_map} ist gut bei Einzel-Operationen
 			\item \texttt{map} erlaubt effiziente Bereichsoperationen (Iteratoren!)
 		\end{itemize}
 	\end{itemize}
\end{frame}

